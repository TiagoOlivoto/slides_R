} else{
quant_var <- aggregate(coverage ~ img, data = object$results, FUN = sum)
}
get_numeric_from_img <- function(x) {
as.numeric(gsub("shp", "", x))
}
quant_var <- quant_var[order(get_numeric_from_img(quant_var$img)), ]
if(!attribute %in% names(quant_var)){
stop("Attribute not found. Have you included it in the `object_index` argument from `analyze_objects_shp()`?", call. = FALSE)
}
quant_variable <- quant_var[, attribute]
coords_list <- object$shapefiles$shapefiles
# Combine all rectangles into one data frame for plotting
all_rectangles <- do.call(rbind, coords_list)
# Define the xmax, xmin, ymax, ymin of the image
xmax <- max(all_rectangles$x)
xmin <- min(all_rectangles$x)
ymax <- max(all_rectangles$y)
ymin <- min(all_rectangles$y)
# Normalize the quantitative variable for color scaling
rr <- range(quant_variable, na.rm = TRUE)
svals <- (quant_variable - rr[1]) / diff(rr)
svals[is.na(svals)] <- 0
# Create the color ramp function
f <- colorRamp(color)
# Calculate colors based on the normalized values and alpha
valcol <- rgb(f(svals)/255, alpha = alpha)
valcol[is.na(svals)] <- rgb(t(col2rgb(col = na.color, alpha = FALSE))/255, alpha = alpha)
# Add RGB image (raster) on the plot
plot(object$final_image)
for (i in 1:length(coords_list)) {
rect(min(coords_list[[i]]$x), min(coords_list[[i]]$y), max(coords_list[[i]]$x), max(coords_list[[i]]$y), col = valcol[i], border = NA)
rect(min(coords_list[[i]]$x), min(coords_list[[i]]$y), max(coords_list[[i]]$x), max(coords_list[[i]]$y), col = NA, border = "black")
}
# Generate the legend
# Generate the legend
pos <- round(seq(min(quant_variable, na.rm = TRUE),
max(quant_variable, na.rm = TRUE),
length.out = classes), round)
if (any(is.na(quant_variable))) {
pos <- c(pos, "NA")
}
col <- rgb(f(seq(0, 1, length.out = classes))/255, alpha = alpha)
if (any(is.na(quant_variable))) {
col <- c(col, rgb(t(col2rgb(col = na.color, alpha = FALSE))/255, alpha = alpha))
}
# Add the minimum and maximum labels to the legend
legend_labels <- c(paste0("Min: ", round(min(quant_variable, na.rm = TRUE), round)), pos, paste0("Max: ", round(max(quant_variable, na.rm = TRUE), round)))
if (any(is.na(quant_variable))) {
legend_labels <- c(legend_labels, "NA")
}
# Add RGB image (raster) on the plot
plot(object$final_image)
for (i in 1:length(coords_list)) {
rect(min(coords_list[[i]]$x), min(coords_list[[i]]$y), max(coords_list[[i]]$x), max(coords_list[[i]]$y), col = valcol[i], border = NA)
rect(min(coords_list[[i]]$x), min(coords_list[[i]]$y), max(coords_list[[i]]$x), max(coords_list[[i]]$y), col = NA, border = "black")
}
# Plot the legend with additional labels for min and max values
legend(legend.position, title = attribute, legend = legend_labels, fill = col, bty = "n", horiz = horiz)
}
# cobertura de solo
plot_index_shp(res, classes = 5)
# Nível de pixel
plot_index(object = res, index = "DGCI")
library(pliman)
library(tidyverse)
setwd("E:/Desktop/UFSC/cursos/pliman_rbras67")
# imagem
img <-
image_import("potatoes.tif", path = "orthomosaic") |>
image_horizontal()
plot(img)
# preparar a imagem
# Somente iterativo
# prep <- image_prepare_mv(img)
prep <-
img |>
image_rotate(-1.976, plot = FALSE) |>
image_crop(width = 194:1075,
height = 140:375, plot = TRUE)
# preparar a imagem
# Somente iterativo
# prep <- image_prepare_mv(img)
prep <-
img |>
image_rotate(-1.976, plot = FALSE) |>
image_crop(width = 194:1075,
height = 140:375,
plot = TRUE)
# índice para segmentação
image_index(prep, index =  "HUE", plot = FALSE) |>   plot_index(viewer = "base")
res <-
analyze_objects_shp(prep,
nrow = 16,
ncol = 9,
index = "HUE",
object_index = c("NGRDI", "DGCI"))
# cobertura de solo
plot_index_shp(res)
# cobertura de solo
plot_index_shp(res)
# imagem
img <-
image_import("potatoes.tif", path = "orthomosaic") |>
image_horizontal()
# preparar a imagem
# Somente iterativo
# prep <- image_prepare_mv(img)
prep <-
img |>
image_rotate(-1.976, plot = FALSE) |>
image_crop(width = 194:1075,
height = 140:375,
plot = TRUE)
# índice para segmentação
image_index(prep, index =  "HUE", plot = FALSE) |>   plot_index(viewer = "base")
res <-
analyze_objects_shp(prep,
nrow = 16,
ncol = 9,
index = "HUE",
object_index = c("NGRDI", "DGCI"))
# cobertura de solo
plot_index_shp(res)
# resumir as informações
results <- get_measures(res)
View(results)
View(results[["summary"]])
hist(results$summary$coverage)
# Nível de parcela
plot_index_shp(res, attribute = "DGCI")
# Nível de parcela
plot_index_shp(res, attribute = "NGRDI")
# Nível de pixel
plot_index(object = res, index = "DGCI")
plot_index(object = res, index = "DGCI", viewer = "map")
image_view(prep)
# imagem
stand <- image_import("stand.jpg", path = "orthomosaic")
# imagem
stand <- image_import("stand.jpg", path = "orthomosaic", plot = TRUE)
# índice para segmentação
image_index(prep, index =  "HUE", plot = FALSE) |>   plot_index(viewer = "base")
# índice para segmentação
image_index(stand, index =  "HUE", plot = FALSE) |>   plot_index(viewer = "base")
# índice para segmentação
image_index(stand, index =  "HUE")
# índice para segmentação
image_index(stand, index =  "HUE2")
image_segment(stand, "HUE")
image_segment(stand, "NGRDI")
image_segment(stand, "NGRDI", invert = TRUE)
# índice para segmentação
image_index(stand, index =  "NGRDI")
image_segment(stand, "HUE")
image_segment(stand, "NGRDI", invert = TRUE)
res <-
analyze_objects_shp(prep,
index = "NGRDI",
invert = TRUE,
nrow = 7,
ncol = 1)
# cobertura de solo
plot_index_shp(res)
View(res)
plot(res$final_image)
# índice para segmentação
image_segment(stand, "HUE")
image_segment(stand, "NGRDI")
image_segment(stand, "NGRDI", invert = TRUE)
res <-
analyze_objects_shp(stand,
index = "NGRDI",
invert = TRUE,
nrow = 7,
ncol = 1)
# cobertura de solo
plot_index_shp(res)
# cobertura de solo
plot_index_shp(res)
# mapeamento das plantas
object_map(res)
# mapeamento das plantas
mapped <-  object_map(res)
View(mapped)
object_mark(res)
mapped <-  object_map(res)
View(res)
View(mapped)
# coeficiente de variação dentro
plot(res$shapefiles)
par(mfrow = c(1, 2))
# cobertura de solo
plot_index_shp(res)
# mapeamento das plantas (distâncias e CV(%))
object_mark(res)
mapped <-  object_map(res)
# coeficiente de variação dentro da linha
barplot(1:7, mapped$cvs)
mapped$cvs
# coeficiente de variação dentro da linha
barplot(mapped$cvs, names(mapped$cvs))
mapped$cvs
# coeficiente de variação dentro da linha
barplot(names(mapped$cvs), mapped$cvs)
barplot
# coeficiente de variação dentro da linha
barplot(mapped$cvs, names(mapped$cvs))
# coeficiente de variação dentro da linha
barplot(mapped$cvs)
# imagem
stand <- image_import("stand.jpg", path = "orthomosaic", plot = TRUE)
# índice para segmentação
image_segment(stand, "HUE")
image_segment(stand, "NGRDI")
image_segment(stand, "NGRDI", invert = TRUE)
res <-
analyze_objects_shp(stand,
index = "NGRDI",
invert = TRUE,
nrow = 7,
ncol = 1)
par(mfrow = c(1, 2))
# cobertura de solo
plot_index_shp(res)
# mapeamento das plantas (distâncias e CV(%))
object_mark(res)
mapped <-  object_map(res)
# coeficiente de variação dentro da linha
barplot(mapped$cvs)
img <- image_import("grains.jpg")
img <- image_import("grains.jpg", plot = TRUE)
par(mfrow = c(1, 1))
img <- image_import("grains.jpg", plot = TRUE)
library(pliman)
library(tidyverse)
setwd("E:/Desktop/UFSC/cursos/pliman_rbras67")
# set_pliman_viewer("mapview")
leaves <- image_import("leaves.jpg", plot = TRUE)
dpi(leaves, viewer = "mapview")
crop <- image_autocrop()
crop <- image_autocrop(leaves)
crop <- image_autocrop(leaves, plot = TRUE)
crop <- image_crop(leaves, viewer = "mapview")
index <- image_index(leaves)
index <- image_index(leaves, "NR")
# Imagem binária
binary <- image_binary(leaves, "NR")
# Índices para segmentação
index <- image_index(leaves, "NB")
# Índices para segmentação
index <- image_index(leaves, "B")
# Imagem binária
binary <- image_binary(leaves, "B")
binary <- image_binary(leaves, "B", invert = TRUE)
binary <- image_binary(leaves,
index = "B",
fill_hull = TRUE)
binary <- image_binary(leaves,
index = "B",
invert = TRUE)
binary <- image_binary(leaves,
index = "B",
fill_hull = TRUE)
binary <- image_binary(leaves,
index = "B",
filter = 10,
fill_hull = TRUE)
binary <- image_binary(leaves,
index = "B",
filter = 5,
fill_hull = TRUE)
binary <- image_binary(leaves,
index = "B",
filter = 3,
fill_hull = TRUE)
binary <- image_binary(leaves,
index = "B",
filter = 5,
fill_hull = TRUE)
# Segmentação
seg <-
image_segment(leaves,
index = "B",
filter = 5,
fill_hull = TRUE)
# Segmentação
seg <-
image_segment(leaves,
index = "B",
filter = 5,
fill_hull = FALSE)
# Segmentação
seg <-
image_segment(leaves,
index = "B-R",
filter = 5,
fill_hull = FALSE)
# Segmentação
seg <-
image_segment(leaves,
index = "B-R",
# filter = 5,
fill_hull = FALSE)
# Imagem binária
binary <- image_binary(leaves, index = "B-R")
# Índices para segmentação
index <- image_index(leaves, "B-R")
# Índices para segmentação
index <- image_index(leaves, "B-R+G")
# Índices para segmentação
indexes <- pliman_indexes()
indexes
lapply(indexes, image_index)
lapply(indexes, \(x) image_index(x))
lapply(indexes, (\(x) image_index(x)))
lapply(indexes, (\(x) image_index(leaves, x)))
# Índices para segmentação
pliman_indexes()
pliman_indexes_eq()
index <- image_index(leaves, index = c("R", "L*"))
index <- image_index(leaves, index = c("RGB", "L*"))
index <- image_index(leaves, index = c("R", "G", "B", "B-R"))
index <- image_index(leaves, index = c("R", "G", "B", "B-G"))
# Imagem binária
binary <- image_binary(leaves, index = "B-R")
binary <-
image_binary(leaves,
index = "B-R",
invert = TRUE)
binary <-
image_binary(leaves,
index = "B-R",
fill_hull = TRUE)
binary <-
image_binary(leaves,
index = "B-R",
filter = 5,
fill_hull = TRUE)
# Segmentação
seg <-
image_segment(leaves,
index = "B-R",
filter = 5,
fill_hull = FALSE)
# Segmentação
seg <-
image_segment(leaves,
index = "B-R",
fill_hull = FALSE)
# Segmentação
seg <-
image_segment(leaves,
index = "B-R")
# Segmentação
seg <- image_segment(leaves,  index = "B-R")
grains <- image_import("grains.jpg", plot = TRUE)
res <- analyze_objects(grains)
res <- analyze_objects(grains, index = "GRAY")
res$statistics
View(res)
View(res[["results"]])
View(res)
# Alguns ajustes possíveis
res <-
analyze_objects(grains,
filter = 3,
index = "GRAY")
# Alguns ajustes possíveis
res <-
analyze_objects(grains,
filter = 2,
index = "GRAY")
# Alguns ajustes possíveis
res <-
analyze_objects(grains,
filter = 3,
show_contour = FALSE,
marker = "point",
index = "GRAY")
# Alguns ajustes possíveis
res <-
analyze_objects(grains,
index = "GRAY",
filter = 3,
show_contour = FALSE,
marker = "point")
# Alguns ajustes possíveis
res <-
analyze_objects(grains,
index = "GRAY",
lower_noise = 0.3,
show_contour = FALSE,
marker = "point")
# Alguns ajustes possíveis
res <-
analyze_objects(grains,
index = "GRAY",
lower_noise = 0.4,
show_contour = FALSE,
marker = "point")
res <-
analyze_objects(grains,
index = "GRAY",
topn_upper = 5,
# lower_noise = 0.4,
show_contour = FALSE,
marker = "point")
res <-
analyze_objects(grains,
index = "GRAY",
topn_upper = 10,
# lower_noise = 0.4,
show_contour = FALSE,
marker = "point")
res <-
analyze_objects(grains,
index = "GRAY",
topn_upper = 10,
# lower_noise = 0.4,
show_contour = FALSE,
marker = "point",
marker_col = "red")
res <-
analyze_objects(grains,
index = "GRAY",
topn_upper = 10,
# lower_noise = 0.4,
show_contour = FALSE,
marker = "point",
marker_col = "red",
show_original = FALSE)
res <-
analyze_objects(grains,
index = "GRAY",
topn_upper = 10,
# lower_noise = 0.4,
show_contour = FALSE,
marker = "point",
marker_col = "red",
show_segmentation = TRUE)
res <-
analyze_objects(grains,
index = "GRAY",
topn_upper = 10,
lower_noise = 0.4,
show_contour = FALSE,
marker = "point",
marker_col = "red",
show_segmentation = TRUE)
res <-
analyze_objects(grains,
index = "GRAY",
topn_upper = 10,
lower_noise = 0.4,
show_contour = FALSE,
marker = "point",
show_segmentation = TRUE)
# Alguns ajustes possíveis
res <-
analyze_objects(grains,
index = "GRAY",
lower_noise = 0.4,
show_contour = FALSE,
show_segmentation = TRUE,
marker = "point")
# Alguns ajustes possíveis
res <-
analyze_objects(grains,
index = "GRAY",
lower_noise = 0.4,
show_contour = FALSE,
show_segmentation = TRUE)
marker = "point"
res <-
analyze_objects(grains,
index = "GRAY",
topn_upper = 10,
lower_noise = 0.4,
show_contour = FALSE,
marker = "point")
plot(res)
View(res)
# Alguns ajustes possíveis
res <-
analyze_objects(grains,
index = "GRAY",
lower_noise = 0.4,
show_contour = FALSE,
show_segmentation = TRUE)
plot(res)
res <-
analyze_objects(grains,
index = "GRAY",
topn_upper = 2,
lower_noise = 0.4,
show_contour = FALSE,
marker = "point")
image_view(grains)
install.packages("latticeExtra")
library(pliman)
image_pliman("sev_leaf.jpg") |> image_index("RGB", ncol = 3)
image_pliman("sev_leaf.jpg") |> image_index("RGB", ncol = 3)
metan::open_wd()
library(keras)
library(pliman)
set_wd_here()
mo <- mosaic_input("soilgrid.tif")
mosaic_view(mo)
mos <- mosaic_analyze(mosaic)
mos <- mosaic_analyze(mo)
Rcpp::sourceCpp("D:/Downloads/cpp.cpp")
